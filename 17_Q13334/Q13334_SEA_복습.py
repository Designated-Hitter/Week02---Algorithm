"""
우선, 1 <= N <= 10만, -10억 <= (h,o) <= 10억, 1 <= d <= 2억
출퇴근 경로인 (h, o)를 선분이라고 표현하겠다.
무작정 답을 구하려면 각각의 경로 N개를 2중 for 문으로 순회해서 각 선분마다 철로를 설치한 후, 다른 선분이 여기 안에 포함이 되는지를 판단하는 방식으로 답을 구할 수 있다. 이 방법은 O(N^2)이라서 연산수가 최대 10만 * 10만이기 때문에 시간초과가 난다.
따라서 O(NlogN) 방법이 필요한데, N은 우선 무조건 선분을 하나씩 순회해야 하므로 소요되고, 순회 내부에서 힙을 사용해서 넣고 빼는 방식으로 logN을 소요한다.

풀이 방법으로, 우선 선분들을 정렬해줘야 한다. 그리고 철로를 각 선분의 끝에 맞춰가면서 철로 내에 선분이 있는지 없는지를 판단할 거라서, 선분들을 끝점 기준 오름차순을 해준다. 끝점이 같은 경우 선분의 길이는 상관이 없다.

이후 정렬된 선분을 하나씩 순회해가면서 힙에 선분이 있으면 조건에 따라 팝 해줄지 말지를 결정해서 하고, 조건을 불만족할 때 while을 빠져 나온 후 현재 선분까지 힙에 넣고 힙의 크기를 답과 비교해서 더 크면 갱신해주면 된다.
"""
import heapq

N = int(input())
lines_info = [list(map(int, input().split())) for _ in range(N)]
d = int(input())
hq = []
lines = []
ans = 0

for line_info in lines_info:
    if abs(line_info[0] - line_info[1]) <= d: # 철로의 길이가 더 큰 경우에만 고려할 대상이다.
        line_info.sort()
        lines.append(line_info)

# 끝점기준 오름차순 정렬
lines.sort(key = lambda x: x[1])

for line in lines:
    # 우선 힙에 선분이 있는지를 확인한다.
    # 있으면 이제 계속 팝 시켜야 하는데 팝되는 조건은 철로의 시작점보다 선분의 시작점이 더 앞에 있는 경우다.
    # 근데 이 최소힙은 선분의 시작점이 작은 순으로 정렬되어 있고, 이 조건을 만족하지 않는 순간부터는 힙에 들어 있는 모든 선분은 시작점이 철로보다 크다. 따라서 while문 빠져나온 후 힙의 크기를 철로 내부에 속하는 선분들로 보면 된다.
    # (끝점이 철로보다 작은건 lines가 끝점기준 오름차순되어 있는 상태이기 때문에 자명하다.) 
    while hq and hq[0][0] < line[1] - d:
        heapq.heappop(hq)
    
    # 위 while을 빠져나온 후, 현재 line을 넣어준다.
    heapq.heappush(hq, line)

    ans = max(ans, len(hq))

print(ans)